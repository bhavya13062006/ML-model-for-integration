# -*- coding: utf-8 -*-
"""MLipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1aVccy3nyevaPZ8txxolRhQ4wBcVb5QeH
"""

# Install only SymPy (no internet required)
!pip install sympy --quiet

import random
from sympy import symbols, diff, integrate, latex, sin, cos, exp, log, tan
from IPython.display import display, Math
import pandas as pd

x = symbols('x')

def generate_calculus_problem():
    """Generate random calculus problem with solution"""
    # Random base function
    choices = [
        x**random.randint(1, 4),
        sin(x), cos(x), exp(x), log(x),
        random.randint(1,5)*x**2 + random.randint(1,5)*x
    ]
    expr = random.choice(choices)

    # Randomly choose integration or differentiation
    if random.random() > 0.5:
        problem = f"Differentiate {latex(expr)}"
        solution = latex(diff(expr, x))
        ptype = "differentiation"
    else:
        problem = f"Integrate {latex(expr)}"
        solution = latex(integrate(expr, x)) + " + C"
        ptype = "integration"

    return {"problem": problem, "solution": solution, "type": ptype}

# Generate dataset
print(" Generating synthetic calculus problems...")
problems = [generate_calculus_problem() for _ in range(1000)]  # Generate 1000 problems
df = pd.DataFrame(problems)

# Verify solutions
print(" Generated dataset:")
print(df['type'].value_counts())

# Show examples
print("\n Sample Problems:")
for i in range(3):
    display(Math(f"{df.iloc[i]['problem']} \\quad \\rightarrow \\quad {df.iloc[i]['solution']}"))

# Save to CSV
df.to_csv('synthetic_calculus.csv', index=False)
print("\n Saved to 'synthetic_calculus.csv'")

# Install required packages
!pip install sympy matplotlib transformers --quiet

import random
import pandas as pd
import matplotlib.pyplot as plt
from sympy import symbols, diff, integrate, latex, sin, cos, exp, log, tan, sqrt, atan
from IPython.display import display, Math

x = symbols('x')

def generate_advanced_problem():
    """Generate challenging calculus problems with solutions"""
    # Advanced function choices
    choices = [
        # Basic
        x**random.randint(1, 5),
        random.randint(1,5)*x**3 + random.randint(1,5)*x,

        # Trigonometric
        sin(x**2), cos(2*x), tan(x/2),
        sin(x)*cos(x), tan(x)*log(x),

        # Exponential/Log
        exp(2*x), log(x+1), exp(sin(x)),

        # Advanced
        sqrt(x**2 + 1), 1/(x**2 + 1), atan(x),
        (x+1)/(x-1), exp(x)*sin(x)
    ]
    expr = random.choice(choices)

    # Random operation with weights (60% differentiation, 40% integration)
    if random.random() < 0.6:
        problem = f"Differentiate {latex(expr)}"
        solution = latex(diff(expr, x))
        ptype = "differentiation"
    else:
        problem = f"Integrate {latex(expr)}"
        try:
            solution = latex(integrate(expr, x)) + " + C"
            ptype = "integration"
        except:
            # Fallback to simpler problem if integration fails
            return generate_advanced_problem()

    return {
        "problem": problem,
        "solution": solution,
        "type": ptype,
        "difficulty": "advanced" if "(" in problem else "intermediate"
    }

# Generate 2000 problems
print(" Generating advanced calculus problems...")
problems = [generate_advanced_problem() for _ in range(2000)]
df = pd.DataFrame(problems)

# Display samples
print("\n Sample Advanced Problems:")
for i in range(3):
    display(Math(f"{df.iloc[i]['problem']} \\quad \\Rightarrow \\quad {df.iloc[i]['solution']}"))

# Add model-friendly columns
df['prompt'] = df['problem'].str.replace("Differentiate ", "diff: ") \
                            .str.replace("Integrate ", "int: ")

df['completion'] = df['solution']

# Split into train/test
from sklearn.model_selection import train_test_split
train_df, test_df = train_test_split(df, test_size=0.2, random_state=42)

print(f"\n Dataset split:")
print(f"- Training samples: {len(train_df)}")
print(f"- Test samples: {len(test_df)}")

# Save datasets
train_df.to_csv('calculus_train.csv', index=False)
test_df.to_csv('calculus_test.csv', index=False)
print(" Saved training and test sets")

# Configure plotting
plt.style.use('ggplot')
fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(12, 5))

# Problem type distribution
type_counts = df['type'].value_counts()
ax1.bar(type_counts.index, type_counts.values, color=['#4C72B0', '#DD8452'])
ax1.set_title('Problem Types Distribution')
ax1.set_ylabel('Count')

# Difficulty distribution
difficulty_counts = df.groupby(['type', 'difficulty']).size().unstack()
difficulty_counts.plot(kind='bar', stacked=True, ax=ax2,
                      color=['#55A868', '#C44E52'])
ax2.set_title('Difficulty by Problem Type')
ax2.set_ylabel('Count')

plt.tight_layout()
plt.show()

# Example statistics
print("\n Dataset Statistics:")
print(f"- Most complex problem: {df.loc[df['difficulty'] == 'advanced', 'problem'].iloc[0]}")
print(f"- Longest solution: {max(df['solution'].str.len())} characters")

from transformers import T5ForConditionalGeneration, T5Tokenizer, Trainer, TrainingArguments

# Initialize model
tokenizer = T5Tokenizer.from_pretrained("t5-small")
model = T5ForConditionalGeneration.from_pretrained("t5-small")

# Training setup (simplified)
training_args = TrainingArguments(
    output_dir="./calculus_solver",
    per_device_train_batch_size=8,
    num_train_epochs=3,
    logging_dir='./logs',
)

print("\n Model ready for training!")
print(f"Architecture: {model.config.model_type}")
print(f"Parameters: {model.num_parameters():,}")

